Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2010-12-11T23:45:32.086871

====== git VCS ======
HELP: man git-log || git help log

*HEAD = reference to last commit in current checked out branch
$git config --global alias.co checkout									<<- make new git alias 
$git config --global color.ui true

**git commands:**

**1)Basic:**
				    //aliases in .profile//

$git remote add [alias] **git@github.com:<username>/<reponame>.git**
$git remote add [alias] master(branch)			<<- add remote branch
$git remote rm [alias]							<<- remove remote
$git remote -v									<<- list push and fetch remote aliases
$git remote rename [oldalias] [newalias]
$git remote show [alias]							<<-tracked branches, branches to prune from local, new remote branches, local branch pushed etc...


$git init											<<- initialize directory to work with git
$git add .					    ga					<<- mark as ready to be commited (mark as updated), staged
$git commit -m "description of commit"	ci	<<- commit to the local repository with a commit message
$git commit -**a**m "message"						<<- commit to local repository ALL **tracked** files and changes, not necesssary to //git add //changes
$git commit -v									<<- puts diff of commit in editor, strips out when file saved
$git commit --amend								<<- replace prev. commit with staging area
$git status (-s[hort])				    gs			<<- clean, updated 
$git push [alias] [branch](existing or new)
$git commit --amend								<<- amend last commit, presumably forgot to add or rm a file from index, or commit with the -a flag


**remove, rename**
$git rm //filename (--cached) (-f)					//<<- remove file from git tracking and delete file from disk (//cached keeps it on disk) (-force is staged)//
$git rm log/\*.log								<<- escape glob patterns, git does its own filename expansion along with shell
$git mv //oldname newname						//<<- runs a git rm --cached, then mv, then git add //newname// 

**remotes**
$git fetch [alias]									<<- fetches updates on remote's references and adds remote branches, if any, and remote commits
$git fetch --all										<<- synch with all remotes
$git merge [alias]/[branch]						<<- git maps branches for you automatically, adding the [alias] for remote branches that differ from other 															people's aliases. These are remote branches.
$git pull											<<- fetches and merges branch on remote that is tracked by branch you're in

$git ls-remote origin -h refs/heads/master		<<- list current HEAD on remote tracking branch
$git remote -v show								<<- show fetch and push URLs for all remotes
$git remote -v update							<<- update refs for remote of current branch and see if it == to local branch

//which remote branch was most recently updated?//
git for-each-ref --format='%(committerdate)%09%(refname)' \
  --sort=-committerdate refs/remotes/



**Getting some SHA1s**
$git ls-remote <URL> (or alias)										<<- check sha1 of branch on the remote repo
$git --git-dir=/path/to/repo/.git rev-parse origin/branch_X		<<- check sha1 of //local //branch_x from anywhere on filesystem
$git --git-dir=/path/to/repo/.git rev-parse --verify HEAD			<<- check sha1 of //local //HEAD from anywhere on filesystem
//Note: references to remote branch heads are stored in //__ .git/refs/remotes/origin/branch_X__
$git ls-files --stage													<<- names and SHA1s of what is in the .git/index dir.



**Updating history on remote (ie 'I made a mistake')**
git push -f origin sha1:branch					<<-  force push the old sha1 to branch

You may have__ receive.denyNonFastForwards__ set on the remote repository. If this is the case, then you will get an error which includes the phrase [remote rejected].
In this scenario, you will have to delete and recreate the branch.

git push origin :alpha-0.3.0
git push origin cc4b63bebb6:refs/heads/alpha-0.3.0



**diff**
$git diff (--stat)									<<- line by line of unstaged changes relative to last commit      (stat) = short summary, status
$git diff --cached	(--stat)							<<- line by line of staged changes relative to last commit
$git diff HEAD (--stat)							<<- line by line of all changes relative to last commit		//equiv. to insertions, deletions if commit now//
$git diff (same as above)
$git diff (--stat) sha1, branchB					<<- suppose sha1 on master and sha1 = merge base (common commit they diverged from), this shows the diff 														between the merge base of master and the tip of branchB, thus all the stuff that was changed in branchB
$git diff master...branchB						<<- same as above (diff the merge base of master with the tip of branchB)

**revert/reset** 
$git reset HEAD //filename						//<<- reset to last commit version, discard changes (default reset is --mixed)
$git reset --hard									<<-  reset working directory to latest commit on branch, discard all changes
$git reset --hard HEAD^1							<<- reset working dir. to one commit ref ago, with a --hard reset
$git checkout -- benchmarks.rb					<<- unstaged, modified file, revert back to index
$git checkout HEAD^ -- fileB						<<- reset fileB to the state it was one commit ago (parent version)
$git checkout -- fileB								<<- revert fileB back to index state (have not added fileB to staging area again)
$git checkout 
git checkout origin/master -- fileB				<<- revert fileB back to state of remote origin/master

**merge conflicts**
git show :3:elisp/dired-details.el > elisp/dired-details.el		<<- :3: is requesting the version of the file from MERGE_HEAD
													     <<- :2: would request the current branch's version
													     <<- :1: would request the common ancestor's version

**branches**
$git branch (-v) (--[no-]merged)					<<- lists branches (-v lists last commit for each branch too) (--[no]merged lists branches that have been 														merged or are currently unmerged

$git merge --no-commit --squash featureB		<<- on featureBv2 branch, merge featureB's muliple commits and squash them to one commit. Also, don't 														perform a merge commit just yet. Next commit will be merge commit.

$git checkout  master           go					<<- returns to master branch 
$git checkout -b [nameofbranch]				<<- goes to either existing branch, or new branch
$git branch -d [nameofbranch]					<<- delete branch after merge(most leave branches intact)
$git branch -D [nameofbranch]					<<- delete branch and changes without first merging
$git branch -m [nameofnewbranch]				<<- rename current branch to nameofnewbranch
$git checkout <hash>								<<- checkout this version of the project
$git checkout (hash, HEAD) //filename//			<<- checkout a commit's version and replace ours with that version 
$git checkout -b serverfix origin/serverfix		<<- make branch serverfix point to same commit that origin/serverfix does. origin/serverfix is a remote 														branch I want to base this work off. Since it points to same commit as remote branch, **auto-tracks remote**
$git checkout --track origin/serverfix			<<- current branch tracks remote branch

**push branches**
$git push origin serverfix:awesomebranch		<<- push serverfix branch to remote, name it awesomebranch. Default no colon, remote same as local
$git push origin :serverfix						<<- delete remote branch serverfix



**merging, fast-forwarding**
$git merge [nameofbranch] 						<<- merges branch with branch you're on, or fast-forwards, rewinds to point to same commit in linear flow

**rebasing (don't rebase commits that have been publicly available)**
$git rebase --onto master server client			<<- rebase client branch, which is based off of commit on server branch, to master branch (don't have to be on 														client to do this)
git rebase [basebranch] [topicbranch]

**cloning**
__$git clone git@github.com:tpope/vim-fugitive.git__		(vim-fugitive folder)	<<- clones repo to folder. Default folder = wd

**blame**
$git blame -L n,m <file>

**log**
$git log [branch]												<<- note that branches take their root's commits
$git log HEAD..branch										<<- log of branch commits not on HEAD branch
$git log [branchA] ^[branchB]								<<- log of branchA commits not on branchB
$git log HEAD...branch										<<- log of branch commits and parallel HEAD commits
$git log --author=Linus --oneline -5							<<- last 5 commits by author, oneline
$git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges		<<- removes merge commits
$git log --grep=P4EDITOR --no-merges						<<- grep commit messages
$git log --grep="p4 depo" --format="%h %an %s" --author="Hausmann" **--all-match	**<<- logically AND the operations, not default OR
$git log -S[userformat_find_requirements]				<<- look through diff of each commit for string
$git show [sha]												<<- shows patch of commit (diff)
$git log -p														<<- put patch after each commit, very verbose
$git log -p file													<<- show all patches for file, doesn't follow renames
$git log --follow -p file										<<- follows renames
$git log --stat													<<- less verbose -p, just # of insertions, deletions, files changed (the diffstat)

//find commit by string: //
$git log --pretty=oneline -S'string'

**reflog**
$git reflog													<<- show the reference log
//note: {0} means 0 positions ago (now). {2} means 2 positions ago//
$git reflog show (branch)									<<- show reflog for this branch, rather than all (default is HEAD, so all)

**format-patch**
//First, make sure to //$git diff --check// before committing //
$git format-patch -M --output-directory /tmp/mypatches 4e3aa87..469cb84		<<- specify two commits, parent and HEAD for HEAD commit (difference b/t parent and 																							HEAD for the patch)
//what changes are in the patch?//
$git apply --stat patchname.patch

//check to see if patch introduces errors://
$git apply --check fix_empty_poster.patch

//applying a patch with signoff://
$git am --signoff < patchname.patch 

//make a patch without committing://
$git diff > result.patch 

//if a few commits are made in a new branch, to patch them into one commit://
$git format-patch master --stdout > fix_whatever.patch							<<- against master


**log formatting**
$git log --pretty=oneline --max-count=2
$git log --pretty=oneline --since='5 minutes ago'
$git log --pretty=oneline --until='5 minutes ago'
$git log --pretty=oneline --author=<name>
$git log --pretty=oneline --all
$git log --oneline --graph								<<- graph for all branches
$git log --oneline erlang ^master						<<- show reachable commits for erlang branch that are non-reachable by master branch
$git log --oneline master ^erlang						<<- show reachable commits for master branch that are non-reachable by erlang branch
$git log --oneline --decorate --graph					<<- decorate means 'show tags'
**since last week:**
$git log --all --pretty=format:"%h %cd %s (%an)" --since='7 days ago'
**GitImmersion 'Ultimate'**
$git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short 		//aliased to hist//
$git hist master --all								<<- shows HEAD, tags, commit messages, hash, author

**tags**
In a version, use:
$git tag											<<- lists all tags
$git tag v1										<<- tags current version of the project
$git tag v1^										<<- tags current version's parent 
$git checkout v1									<<- checkout tag
$git tag -a v2.0									<<- annotate tag with info
$git tag -a v0.9 558151a							<<- retroactively tag that commit
