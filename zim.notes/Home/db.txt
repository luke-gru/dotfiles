Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2010-12-13T18:16:15.312089

====== db ======
for business data validations (in Model), see [[Home:Rails Methods|Rails Methods]]

**Find items from database: (class method .find, not enumerable method .find)**

→ __Model.find__															<<- returns object, or raises **ActiveRecord::RecordNotFound** exception
//Model.find(1)//			<<- with an ID of 1 (ID is a //primary key)//					
//Model.find(:all)		//<<- returns all

//Example: (in Product model in depot app)//
def self.find_products_for_sale
		__find__(__:all__, __:order__ => "title")		<<-- This looks at all rows in the table //products// and returns a big array containing each object found. The arrays are  	end											ordered by title

→ __User.find_by_email__("**luke.gru@gmail.com**")				<<- __Model.find_by_attribute(attribute)__ this returns nil or row (in this case, user row)

→ __user.save__												<<- return is boolean

→ __user.destroy__											<<- returns destroyed object

→ __user.update_attributes__(:name => "luke", :email => "**luke@foo.org**")	<<- **updates** and **saves** accessible attributes (__attr_accessible__) see [[Home:Rails Methods|Rails Methods]]

→ __user.reload(.email)__							<<- reloads info from written db values and overwrites attributes in memory

→ __user.name = "pie"__								<<- database info changes, but not written to (if user.save called  after, then it's written)

→ __user.name.blank?__								<<- true if only whitespace

→ __user.valid?	__									<<- true if can save attributes (passes validations)

→ __User.create(:name => "luke", :email => "gru")__				<<- //.new and .save// at same time. Returns the object, even if it failed validation

→ __User.create!(:name => "", :email => "")__						<<- when fail to save, raises **ActiveRecord::RecordInvalid**: Validation failed: Name can't be 																		blank 



**ActiveRecord** **Pre-Migration Tasks [adding columns, adding attributes to columns, adding model instances, adding index] (in "root"/db/migrations):**

1) **class** __AddPriceToProduct__ < ActiveRecord::Migration				<<- because of a rails generate newcolumnindatabase command
	**def** __self.up__
		__add_column__ :products, :price, :decimal,				<<- add column (attribute) to //products// table called __price__
		:precision => 8, :scale => 2, :default => 0

	**end**

	**def** __self.down__

		remove_column :products, :price

	**end**

**end**

Here, the price is in //:decimal //to avoid Ruby rounding off the price.
→ ://precision// = digits, //:scale //= number of digits after decimal point, //:default //= default value for column
//:limit => 10				<<- //limit 10 chars

2) **class** __AddTestData__					<<- for more info. on adding test data, see Hammock p. 90

Product.delete_all               <<-- Deletes all entries in the Product model

 Product.create(:attributes(//:title// => "Infinite Jest", //:price// => 20.00, etc...)

3) 

//First://
__$rails generate migration add_email_uniqueness_index__
//Then://
class AddEmailUniquenessIndex < ActiveRecord::Migration
  def self.up
    **add_index** :users, :email, :unique => true								<<- makes sure email is unique in users table on the //database// level as well
  end

  def self.down
    **remove_index** :users, :email
  end
end


**Table Associations in pre-migration tasks:**
4) More complicated Pre-Migration Tasks

class CreateLineItems < ActiveRecord::Migration
  def self.up
    create_table :line_items do |t|
      t.integer :product_id, __:null => false__, __:options__ => "CONSTRAINT fk_line_item_products REFERENCES products(id)"		<<- value != null	
      t.integer :order_id, :null => false, :options => "CONSTRAINT fk_line_item_orders REFERENCES orders(id)"
      t.integer :quantity, :null => false
      t.decimal :total_price, :null => false, :precision => 8, :scale => 2

      t.timestamps
    end
  end

* In Example Above:
//:options => "CONSTRAINT fk//__(foreignkey)__//_line_item//__(one row in table)__//_products//__(table i'm referencing)__// REFERENCES products//__(table)__//(id)//__(attribute)__

									Product has_many// :line_items//
									Order has_many //:line_items//
									Line_items belongs_to //:order, :product//

									

Note that now the database knows about the table interrelationships. Rails, however, does not. Look at [[Home:Table Associations|Table Associations in Rails]] for more info.

//More Examples://

t.string :pay_type, __:limit => 10__							<<- limit 10 chars


*To see how this adds navigation ability for Model objects, see [[Home:Table Associations|Table Associations]] 

**Adding index to table attribute in pre-migration tasks:**

class AddEmailUniquenessIndex < ActiveRecord::Migration
  def self.up
    __add_index__ :users, :email, :unique => true										<<- add index to users table on email attribute, to make it unique
  end

  def self.down
    __remove_index__ :users, :email
  end

end





