Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2011-07-03T21:12:25.432195

====== Metaprogramming ======

**Cool libraries w/ lots of metaprogramming techniques:**
facets
rake
[[Home:Ruby:Metaprogramming:Rails|rails]]

**Modules and mixins - caveat**
Note that Module static methods are useless when included or extended in a class, as only their instance methods are accessible from classes that include them.

__Module.constants__	=> return all top-level constants

__Module#constants__ 	=> return all constants in the current scope

__Module.nesting__		=> return array of module namespace information for the current namespace

**Anonymous singleton classes vs class objects**

class << Test
self here is Test's anonymous singleton class, so defining an instance method here is the same as below

end

class Test
	def self.hello

		puts "hello"

	end

end

Test.hello

**Hook methods**

Class#inherited
Module#included(host)									<<- can override what happens w/ Module#append_features
Module#extended(host), Module#extend_object
Module#method_added									<<- these method hooks only work for non-singletong methods
Module#method_removed								<
Module#method_undefined								<
Kernel#singleton_method_added						<< these method hooks work for singleton_methods
Kernel#singleton_method_removed					<
Kernel#singleton_method_undefined					<

**Hook Basechange**
//fiddle around with the base class on an include/extend//
Example:

module ActiveRecord
	module Validations

		def self.included(base)

			base.extend ClassMethods
			base.class_eval do
			alias_method_chain :save, :validation			=> the methods are defined below! Ruby calls included after including all methods (last)
			alias_method_chain :save!, :validation

		end
		base.send :include, ActiveSupport::Callbacks
		# ...

	end
	def save_with_validation(perform_validation = true) # ...
	def save_with_validation!
	# ...


**Hook Catch**
Catch a call to include or extend, and do what you want with it. Don't forget to call **super**

redefine Yourclass::include, then call //super//
redefine YourObject#extend, then call //super//

**Mixin/Extension**
module Merb::Cache::CacheMixin
	def self.included(base)

		__base.extend(ClassMethods)__

	end
	module ClassMethods

		def cache(*actions)

	# ...

**Ghost methods**
def Object.__const_missing__(name)						<<- Module#const_missing. Define it on any namespace!
	name.to_s.downcase.gsub(/_/, ' ' )

end
MY_CONSTANT
# => "my constant"

**Undefining methods:**
Module#undef_method( ) 								<<- removes all methods (including inherited)
Module#remove_method()								<<- removes method from receiver only

class BlankSlate
# Hide the method named +name+ in the BlankSlate class. Don't
# hide +instance_eval+ or any method beginning with "__".
	def self.hide(name)

		if instance_methods.include?(name.to_s) and
		name !~ /^(__|instance_eval)/
		@hidden_methods ||= {}
		@hidden_methods[name.to_sym] = instance_method(name)
		undef_method name

	end

end

instance_methods.each { |m| hide(m) }
		
**Reserved Methods:**
Kernel#____send____
Kernel#____id____

**Scope gates:**
__def__
__class__
__module__

**Flattening scope gates:**
Class.new
Module#define_method
Module.new

**//caveat**//
self here is changed, as //puts self //gives what you'd expect
@vars and @@vars are NOT changed, still have to access them with instance/class_variable_get/set

**Shared Scoping:**
def define_methods										<<- the variable //shared// is protected by a scope gate (__def__)
	shared = 0
	Kernel.send :define_method, :counter do

		shared

	end
	Kernel.send :define_method, :inc do |x|

		shared += x

	end

end

define_methods
counter			=> 0
inc(4)
counter			=> 4

**Context Probe:**
v = 2
obj.instance_eval { @v = v }					=> adds new binding to evaluate expressions, doesn't leave old one
obj.instance_eval { @v }						# => 2

**Deferred Evaluation:**
inc = Proc.new {|x| x + 1 }
# more code...
inc.call(2) 										# => 3


**Class Eval (Module Eval):**
instance_eval( ) only changes self (not //really, //though), while
class_eval( ) __changes__ both __self__ and the __current class__.

Module#class_eval is actually more flexible than **class**. You can use
class_eval on __any variable that references the class__, while **class** requires
a constant. Also, **class** opens a new scope, losing sight of the current
bindings, while class_eval has a //Flat Scope//

**Nil Guard:**
Very useful when testing dynamic data

**Class Macros**
class methods that generate instance methods. Like attr_reader, writer, accessor

**Instance Eval and Class Eval:**
instance eval changes self to receiver, and also changes the class to the receiver's singleton class.
Note however that this only works with def ... end and //not with //define_method

class eval changes self to receiver also but changes the class to the receiver, too! Also, the receiver
must be a class!

**Class Instance Variables:**

**Around Aliases:**
alias //:newmethod :oldmethod							//=> alias is a __keyword__, so there's no comma. Use alias_method //:newmeth, :oldmeth //to dynamically alias methods

Then, redefine oldmethod!

**Define_method:**
//private method//
returns a proc if w/ block. Also, evaluates the block in the co4
ntext of instance_eval on the receiver of the method

**Eval:**
evaluates__ strings of__ any __code__, including anything in scope at the time, like variables.
eval('string_of_code', binding, file, line) 					=> last 2 args for stack trace

see //metaprogramming ruby p. 164//
see //"", p. 173 for info on Sandboxing and SAFE levels//

**Bindings:**
//pure scope, no code associated w/ it//
to return a binding, use Kernel#binding
Bindings can be used w/ Kernel#eval, BasicObject#instance_eval and Module#class_eval
