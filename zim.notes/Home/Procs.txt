Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2010-12-20T20:05:20.711460

====== Procs ======

→ Procs are blocks that become objects.
→ see Pickaxe p.340

//Here’s the big thing to remember:// raw procs (non-lambda procs) are basically designed to work as the bodies of
control structures such as loops. Lambdas are intended to act like methods. So, lambdas are
stricter when checking the parameters passed to them, and a return in a lambda exits much as it
would from a method.


**Creating a Proc:**
__Proc.new__, __lamba__, //method//(otherparam, __&__procparam) 							<<- lambda { |params| ... } = 	__->(params) {...}__ in Ruby >=1.9
		<<- First two differ a little in behavior

def create_block_object(__&__block)
	block
end

bo = create_block_object { |param| puts "You called me with #{param}" }
bo__.call__ 99
bo__.call__ "cat"
produces:
You called me with __99__
You called me with __cat__

**Proc in method: (variables within block are in **__outer scope__** as well, for life of block and Proc objects created by block): **More in Pickaxe p. 83
def n_times(thing)
	__lambda__ {|n| thing * n }
end
____
p1 = n_times(23)								=> Proc object			thing = 23
p1__.call__(3)										=> 69						n = 3, thing = 23
p1__.call__(4)										=> 92						n = 4, thing = 23
p2 = n_times("Hello ")						=> Proc object			thing = "Hello "
p2__.call__(3) 										=> "Hello Hello Hello "        n = 3, thing = "Hello "


**More Examples of passing blocks (as procs) to methods: (lambda to arg, and { .. } to &block)**
def my_while(cond, __&__body)
	while cond.call
	body.call
	end
end

a = 0
my_while__ ->__ { a < 3 } __do__					<<- //cond// is lambda proc
puts a										<<- //body// is passed as proc to the method with the & character (has to be last method argument)
a += 1
__end__
=>
0
1
2
