Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2010-12-20T20:05:20.711460

====== Procs ======

→ Procs are blocks that become objects.
→ see Pickaxe p.340

//Here’s the big thing to remember:// raw procs (non-lambda procs) are basically designed to work as the bodies of
control structures such as loops. Lambdas are intended to act like methods. So, lambdas are
stricter when checking the parameters passed to them, and a return in a lambda exits much as it
would from a method.

Procs are used to pass blocks around to different methods, and to convert blocks to procs for other uses.


**Creating a Proc:**
__Proc.new__, __lamba__, //method//(otherparam, __&__procparam) 							<<- lambda { |params| ... } = 	__->(params) {...}__ in Ruby >=1.9
		<<- First two differ a little in behavior

def create_block_object(__&__block)
	block
end

bo = create_block_object { |param| puts "You called me with #{param}" }
bo__.call__ 99
bo__.call__ "cat"
produces:
You called me with __99__
You called me with __cat__

**Proc in method: (variables within block are in **__outer scope__** as well, for life of block and Proc objects created by block): **More in Pickaxe p. 83
def n_times(thing)
	__lambda__ {|n| thing * n }
end
____
p1 = n_times(23)								=> Proc object			thing = 23
p1__.call__(3)										=> 69						n = 3, thing = 23
p1__.call__(4)										=> 92						n = 4, thing = 23
p2 = n_times("Hello ")						=> Proc object			thing = "Hello "
p2__.call__(3) 										=> "Hello Hello Hello "        n = 3, thing = "Hello "


**More Examples of passing blocks (as procs) to methods: (lambda to arg, and { .. } to &block)**
def my_while(cond, __&__body)
	while cond.call
	body.call
	end
end

a = 0
my_while__ ->__ { a < 3 } __do__					<<- //cond// is lambda proc
puts a										<<- //body// is passed as proc to the method with the & character (has to be last method argument)
a += 1
__end__
=>
0
1
2

**Defining methods with &blocks**
def math(a, b)
	yield(a, b)

end

def teach_math(a, b, __&operation__)					<<- passes the block as a proc to the next method
	puts "Let's do the math:"
	puts math(a, b,__ &operation__)

end
teach_math(2, 3) {|x, y| x * y}
####
Let's do the math:
6

**Calling methods with &blocks**
def my_method(greeting)
	puts "#{greeting}, #{yield}!"

end
my_proc = proc { "Bill" }
my_method("Hello" ,__ &my_proc__)					<<- turns the proc back into a block when it hits the method
####
Hello, Bill!

**Turning a Proc into a method:**
prok = Proc.new {|x| x + 1}

MyClass.__send__(:define_method, :other_method, &prok)

**Turning a method into a Proc:**
m = object.method :my_method						<<- only bound methods can be turned into procs!
p = m.to_proc


