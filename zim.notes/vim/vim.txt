Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2010-12-20T19:20:41.147318

====== vim ======
*[[vim: Opening a vim session|Opening a vim session]]
My VIM plugins: //vim.rails, vim.project, vim.snipmate, vim.surround, autotags (need exuberant ctags), fugitive, vimball//

--Vim, Gvim resource and command list--

**Getting Help:**
__:h(elp) 'option'__							<<- options are set in ~/.vimrc
__:h user-toc.txt__							<<- table of contents for user's manual
__:h [nameofplugin]__						<<- help doc for plugins
__:helpg(rep) [word]__						<<- grep a string within help doc. (cwin to show quicklist)
**OPTIONS::**
**Is this option on?**
:set compatible?							<<- 'nocompatible'
**Mappings for options:**
<F11>										<<- set virtualedit=all
<F9>										<<- set virtualedit=
__________
**Normal Mode:**
C-L											<<- redraw screen after err. mess. messup
J, gJ										<<- joins the next # lines together. (default = .+1)  	gJ=nojoinspaces	J=1 \w joinspace
C-u											<<- like page-up
C-d										<<- like page-down
ge, gE										<<- backwards end-of-word (WORD)
C-w w										<<- switch to next window (wrap on)
C-w _										<<- make current window as high as possible
C-w (hjkl)[HJKL]							<<- (move to window left, below, up, right)  [move this window to fullest HJKL]
C-w t										<<- move to top window
C-w b										<<- move to bottom window
C-w x										<<- exchange windows with the next one
C-w T										<<- move window to new tab when current tab contains > 1 window
c2w										<<- change 2 words (delete 2 words and put me in insert mode)
C- 6										<<- last edited buffer
gt, gf										<<- go to next tab, next file (in set path)
'"											<<- when jumping, brings you to cursor pos. before jump
R											<<- replaces text, swallowing it, put in //replace// mode
gR											<<- virtual replace mode, fancy stuff
gV											<<- visual mode, only one command, then back to normal @ b.o.l. good for macros
gH											<<- select mode, linewise
C = c$
D = d$
s = cl, stay in i_mode						<<- change one character (x = dl)
r = 	cl w/out having to ESC				
.											<<- repeat last change command that wasn't u or a **:** command (can be / command)
f<, F<										<<- find first < occurence forwards, backwards  (repeat same dir w/ **;** and other dir w/ **,**
t<, T<										<<- find first < occurence backwards. same repeats as f and F
]m, [m										<<- find next method, find prev. method 
V											<<- v-mode whole line
C-v											<<- v-block-mode (on axis point)
p											<<- puts register somewhere (context-created)	ddp= line below cursor dwp = after cursor
P											<<- puts opposite dir.
shift-ins OR "+p							<<- puts from  real clipboard
:[line]pu [x]								<<- puts the text [from register x] before [line] (default current line)
"+y$ 										<<- yanks to real clipboard, cursor to end of line
"*y											<<- yank to cs clipboard
diw										<<- delete inner word (entire word, like dw but cursor not at pos. 0) //see text-objects//
~											<<- swapcase
=											<<- indent
qa Commands q							<<- record Commands in variable a [a-z]
(N)@a										<<- invoke the recording of a
5:											<<- means 5 lines. (becomes .,.+4 for range in cmd mode)
**g** C-**g**							   <<- count **g**oddamn words (can use in **v-mode** also)
C-g										<<- file info 
q:											<<- open command-line window
C-A										<<- inserts last insert
ga											<<- shows ASCII
NzF										<<- folds next N lines 
zj, zk										<<- move down to beginning of next fold, move up to end of prev. fold
zC											<<- close folds recursively
zO											<<- open folds recursively
zM											<<- close all folds in current window

**Manipulating registers:**
after recording, can puts register with:
"np										<<- will show up as edits instead of text
//then change the edits//
"ny											<<-  yank the new edits to the register (here, n)
"AY										<<- append to register "aY
_dd 										<<- black-hole register, don't put the result of this destructive operation into the "" register
"-											<<- small delete register
"0-9										<<- "0 contains most recent yank command (near **y **key), while "1 contains most recent change command (near c key)
**Marks:**
mt											<<- could use this for mark top
mb										<<- could use this for mark bottom
now, ranges can be specified as 't, 'b	<<- note that ' gives you only row, first non-\s, ` (backtick) gives you cursor pos.

**Colon** **Commands and Ex Commands (see cmdline.txt)**
//:saveas filename//
//:file filename								//<<- rename file, no write
//:read filename							//<<- puts file text one line below cursor
://0r !ls	//									<<- first line of file, print output of terminal 'ls' in current working dir.
//:new										//<<- open new horiz. [noname] window
//:split										//
//:vnew										//<<- open new vert.   [noname] window
//:vsplit									//
//:tabnew//
:3tag										<<- jump forwards 3 tags
//:#r filename								//<<- reads file and inserts it after current line. #s can be used to insert it at line #
//:view filename							//<<- open file in read-only
//:write  >> filename						//<<- appends all text to file (or selected text when in v mode)
//:[ran,ge]s/oldword/newword[tags]		//<<- % is general sub (default range = current line #, and first occurence of each line only)
//:%s/Professor/Teacher/g					//<<- g tag is a global sub, every occurence, not just first of each line.
//:![range]command//						<<- performs command on selected lines
//:!!command								//<<- standard output of command into text, replaces line with text (e.g. !!date).  	Also: //0r !date -u   //inserts text
//:grep error_string *.c//						<<- grep inside vim, tags files and line numbers, use //clist, cnext, cprev to move around //
//:bufdo										<<- //operate on every file in buffer list
//:ar(gs) *.rb								<<- //put all .rb files (in current dir) in the argslist
//:argdo										<<- //operate on every file in argslist
//:digraphs									//<<- list digraphs //i_C-k xx// will insert a digraph 
:.,/here print								<<- print current line to 'here' match
:C-f										<<- switch to command-line window
:args `grep –l ‘frame_counter’ *.c`		<<- add all files that contain 'regexp' (frame_counter) and have a filename match of '*.c' to the argslist
: grep -w sometext *.c					<<- w flag for whole word

**Global Commands:**
//:g //

**/ Search Commands /**
/pat1//pat2/								<<- find line containing pat1 after line containing pat2, keep cursor point
7;/pat2/


**Substitution Commands:**
c-flag										<<- **careful.** Prompt me at each match
e-flag										<<- **error-free.** Don't find a match in a file, no error returned. Useful for $vim *.rb, qq, /../ //:wnext//, q, @q, 999@q
:%s/\<four\>/4/**g**							<<- **global sub. ** not just first occurence on each line!  \< is beginning of word, \> is end of word, here just wants the 												word //four, //not //fourteen//
:%s/\([^,]*\), \(.*\)/\2 \1/					<<- changes, __Lastname, Firstname__ to __Firstname Lastname__. \ paren, ^ means //not//, \1-\9 are backreferences
mt :'t+1,.g/^/m 't							<<- mt first line, move cursor to last line, this command reverses the line order		
:%s/\s\+$//								<<- shed whitespace line-endings
:argdo %s/\<x_cnt\>/x_counter/ge | update		<<- the | is a command separator, command invoked after the first in all files. update = save if change




**Command-line editing:**
*supports multiple tab-line completion, <tab> is next, <C-h> is prev.*
*q: opens cmd-line history for execution of commands
*history and history /: up, down, match, completion works here
<C-h/C-l>									<<- one char back, forward
<C-j>, <C-k>								<<- one word back, forward
<C-w>										<<- delete word 
<C-u> 										<<- restart command
<insert>									<<- overstrike mode
<C-b>, <C-e>								<<- go to beginning, end


**Visual Mode Commands:**
//block mode://
Itext<ESC>								<<- insert text for each line selected with visual block mode
$Atext									<<- appends text after each line
ctext										<<- change selected text on each line
Ctext										<<- change selected text until end of line on each line

~, U, u also work							<<- swapcase, upper, lower
<<, >>										<<- indent, remove indent
<C-g>										<<- in visual, switch to select mode. In select, switch to visual mode

**any:**
J											<<- join selected lines
zf											<<- fold

**Insert Mode Commands**
C-v (F1)									<<- writes <F1>, takes the (next char) literally. Good for editing .vimrc
C-n											<<- tab-like completion for i_mode
C-r	r										<<- insert register "r (C-r " is insert current register)
C-k											<<- insert digraph
C-x C-f										<<- filename search, grep current directory (C-x [crosshair mode])
C-x C-d									<<- macro definition search
C-x C-k										<<- dictionary word search

C-w										<<- delete word before cursor
C-u											<<- delete stuff i just inserted

**Using Registers (places where Vim stores text):**
"fyas										<<- yanks a sentence, stores in register f
"l3Y										<<- yanks 3 lines, stores in register l
"fp											<<- puts register f
"wdaw										<<- delete a word, put it in the w register


**Printing and Converting formats:**
//:TOhtml									//<<- converts the file to html		


**PLUGINS::**
**Rails Plugin:**
:A(T,W)									<<- alternate file (usually tests)
:R											<<- related file: 						 (**Model:**__schema_migration__**		Controller:**__Module__**	View:**__Controller__)
:Rmo, Rco, Rvi							<<- specific related file //--very useful//
:Rfind										<<- useful w/ tab 
C-w f										<<- edits file under cursor in new split
gf											<<- edits file under cursor in current win.
C-w gf										<<- edits file under cursor in new tab

**Project plugin:**
//:Project (F12)//								<<- opens project window (F12 is my map)
:\C											<<- set up project				(file filter = "*.rb *.html.erb *.js.rjs
//:saveas ~/.projects/projname				//<<- save project
//:r ~/.projects/projname					//<<- load project (mapped to __proj__)


_________

**Surround plugin:**
ds"										<<- delete surround "
cs"'										<<- change surround from " to '
dst										<<- delete surrounding tag
ysw"										<<- y to escape //sub.//
//vmode://
s"
yds"										<<- the y (mnemonic is '//yeah, so...')// is to escape the delete command
ycs'"
**SnipMate plugin:**


**Help**
//user_27://  offsets, searching, basic regex
//user_28: //manual folding, folds w/ markers, folds based on expressions, vimdiff autofolding, indent folding, syntax folding
//user_29: //ctags and cscope (bunch of C stuff)
//user_30: //formatting, textwidth, formatoptions, comments
//user_31: //gui stuff
//user_32: //undo, forward in time, backwards in time
//user_40: //mappings, making commands, autocommands, eventignore
//user_41: //built-in functions, how to script, basic VimL scripting language

