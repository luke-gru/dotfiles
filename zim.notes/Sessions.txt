Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2010-12-10T18:08:55.992843

====== Sessions ======

The cookies utility is important here.
* __The session  object acts like a hash__
* __Once the session has begun, it is available across requests until it is made nil__
**Options for database storage for sessions:**
//This stores sessions IN the database. NOT the cookie solution. confidential info. should NOT store here. //
//Have to uncomment following line in config/environments/initializers/session_store.rb and then restart server//
â†’ config.action_controller.session_store = :active_record_store


**Sessions and Carts:**
//in StoreController://
def find_cart
		unless session[:cart]													<<- session object treated like hash
			session[:cart] = Cart.new
		end
		session[:cart]
end

def add_to_cart
		product = Product.find(params[:id])
		@cart = find_cart													<<- same as self.find_cart
		@cart__.add_product__(product) #can use the add_product method because it is a Cart instantiation		<<- **add_product def in Cart model**
end

__Here, session[:cart] is a Cart.new instance, so Cart instance methods are available to @cart.__

The method __add_to_cart__ is applied when the button is pressed.

So, the button_to [[Home:Helper Methods|helper]] method in the view is like this:


<%= button_to "Add to Cart", __:action => "add_to_cart"__, __:id => product__ %>				<<- product is the variable defined in the //add_to_cart// method


//Meanwhile, in the views department, in app/views/store/add_to_cart.html.erb//

<h2>Your Pragmatic Cart</h2>
<ul>
	<% @cart.items.each do |item| %>					
		<li><%= item.title %> &times; <%= item.product %></li>			<<- **This is tricky**. @cart is the //session object// holding the cart. Items is an array 																					containing //CartItems//.new. So when we iterate over @cart.items, we can 																					only invoke //CartItem// instance methods
	<% end %>
</ul>

Now, how to [[make a smarter cart]].

**How to empty a session (example in depot):**

def empty_cart													<<- and then //button_to //__empty_cart__ in the //add_to_cart// view
		session[:cart] = __nil__
		flash[:notice] = "Your cart is currently empty"
		redirect_to :action => 'index'
end


**Cookie-based approach:**
(not including tests)

1. Create a sessionscontroller with the **new, create and destroy **REST actions.

2. 
	  **resources :sessions**, __:only __=> [__:new, :create, :destroy__]
	  match '/signin',  :to => 'sessions#new'
	  match '/signout', :to => 'sessions#destroy'
	
	#then the sessions#create action will be handled at the sessions_path, because of the resource


3. since there's no corresponding model to the controller, need to be more specific with __form_for__

__form_for__**(:session, :url => **__sessions_path__**)**

then make the labels and text_field, password_field and button for email and password

4. authenticate user unless user.nil?

5. remember that invalid signin won't create error messages, we have the flash.now and re-render 'new' action

6. __include__ the SessionsHelper into ApplicationController and make a __sign_in__ method in the helper for the action __sign_in__ that is used in the create action of the sessionscontroller unless user.nil? == true

def__ sign_in__(user)
    cookies.permanent.signed[:remember_token] = [user.id, user.salt]				<<- permanent (20 yrs), signed (cannot see id in browser)
    **self**.current_user = user
  end

7. 

def __current_user__
    @current_user ||= user_from_remember_token
  end

  private

    def __user_from_remember_token__
    ***  User.authenticate_with_salt(*****remember_token)	***				<<- * allows to take array elements passed to arguments
    end

    def **remember_token**
      __cookies.signed[:remember_token]__ || __[nil, nil]__
    end
end

and an attr_writer for current_user

8. Define the *** User.authenticate_with_salt(id, salt) method

def __self.authenticate_with_salt__(id, //cookie_salt//)
    user = find_by_id(id)
    ((user) && (user.salt == //cookie_salt//)) ? **user** : **nil**
  end

9. and then define the very useful __signed_in?__ method in the sessionscontroller as well:

def signed_in?
    !current_user.nil?
  end

10. Fine I'll add some test code... this great sessions_controller_spec code:

it "should sign the user in" do
  post :create, :session => @attr
 ** controller**.current_user.should == @user
  **controller**.should be_signed_in
end

11. the signout: 
def __sign_out__
    cookies.**delete**(:remember_token)
    self.current_user = nil
  end

12. create signin upon signup

13. make sure certain links and divs are not seen when not signed_in

14. Time for some access control!

