Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2010-12-09T20:07:50.341475

====== Ruby Regular Expressions ======

Use: Match pattern against strings

Use -v : 
→ You can test a string to see whether it matches a pattern.										=~ (match)	!~ (doesn't match)
→ You can extract from a string the sections that match all or part of a pattern.
→ You can change the string, replacing parts that match a pattern.

!Class => Regexp	 !Parent Class => Object

Resources: [[http://www.rubular.com|Rubular]] [ a Ruby regular expression editor], [[http://strugglingwithruby.blogspot.com/2009/05/regular-expressions-in-ruby.html|StrugglingWithRuby]]
Legend: Ruby Regular Expression => RRE
_______________________________________________________________________________________________________________________________________

→ **Create a RRE:**

Regexp.new("...", "i") OR [[/.../]] OR %r{ ... }  OR regexp::new (constructor) or #{...}

→ **Comparison methods:**  RRE.match(string)   and   =~ (operator)
						        => [[matchdata			]]       => index of first match

								    bothmethods => [[var $~]]


→ **Rules for RREs:**

	.             any character except newline
	[ ... ]     any single character of set
	[^ ]       any single character NOT of set

*?          0 or more previous regular expression (non-greedy)
+           1 or more previous regular expression
+?         1 or more previous regular expression (non-greedy)
?            0 or 1 previous regular expression
??

	  [characterclass]

	[abc]		a single character: a, b or c
	[^abc]		any single character but a, b, or c
	[a-z]		any single character in the range a-z
	[a-zA-Z]	any single character in the range a-z or A-Z
	[a-z&&[^aeiou]] 			<<- this means a-z, but not a vowel. && intersects char. classes
	
	escape: - and ]

	
	|              alternation
	( )           grouping regular expressions
	^             beginning of a line 
	$             end of a line 
	{m,n}    at least m but most n previous regular expression
	(m,  )   	m or more of previous expression
	{m,n}?  at least m but most n previous regular expression (non-greedy)
	{m}	m occurences of prev. regexp


	\1-9       nth previous captured group **
	\A          beginning of a string
	\b          backspace(0x08)(inside[]only)
	\b          word boundary(outside[]only)
	\B          non-word boundary
	\d          digit, same as[0-9]
	\D          non-digit
	\h		hex-digit [0-9a-fA-F]
	\H		non hex-digit
	\S           non-whitespace character
	\s           whitespace character[ _ \t\n\r\f]
	\W         non-word character
	\w          word character[0-9A-Za-z_]
	\z           end of a string
	\Z           end of a string, or before newline at the end
	\/            forward slash

//Options://
	i		case insensitive
	o		return first match only
	m		"." now matches any character including \n
	x		can now insert spaces and newlines, and make #comments
	
	RRE's can also take blocks: 
	//Example://
	def mixed_case(name)													<-- .capitalize each word in a pattern

		name.downcase.gsub(/\b\w/) {|first| first.upcase }

	end
	
	*Al//so, you can give gsub and sub a HASH! see Pickaxe p. 121//
	
	*→ puts "fred:smith".sub(/(\w+):(\w+)/, __'\2, \1'__)						=> smith, fred				<<- capture groups passed as second argument
	*→ puts "nercpyitno".gsub(/(.)(.)/, __'\2\1'__)								=> encryption



	*encodings:	Pickaxe p. 115	
	
	** $1 is the global variable representing the first captured group (...) inside a regexp. Subsequent capturings: $2, etc...

